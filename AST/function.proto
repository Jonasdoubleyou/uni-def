syntax = "proto3";

import "module.proto";
import "type.proto";

message Function {
  /* The id of this function, must be unique inside the modules functions. "main" functions got the id 0 */
  int32 id = 1;

  /* The name of the function. The UNI parser only uses the id and does not use
     the reference, therefore it can be removed at building time to shrink module size */
  /*parser-optional*/ string name = 2;

  /* The parameters this function takes, parameters are basically just variables */
  repeated Variable parameters = 3;

  /* If a Function has a parent Function, it can only be called from within that function.
     Through that arguments of the parent function can be accessed,
     effectively enabling what's called a Closure in other languages.

     If it has no parent, it can be called from everywhere,
     the Module."main" function has to have no parent.
  */
  // optional
  // FunctionReference parent = 4;

  /* When set to true, a return inside of this function will directly
     unwind the callstack until the closest function "parent" is reached,
     then that will return with the same value this function returns.
  */
  //optional
  // bool innerReturn = 5;

   /* The result's type when doing a FunctionCall, equals the last Expression.type of body */
   TypeReference returns = 6;

   /* The variables can only be accessed inside this function and its children */
   repeated Variable variables = 7;

   /* The "code" executed when calling this function*/
   repeated Expression body = 8;
}

/* A way to refer to functions, "function" has to be unique inside the modules functions */
message FunctionReference {
  int32 moduleID = 1;
  int32 function = 2;
}

/* A variable reference resolves to a Variable (holding a value) inside a function (that has to be in the callstack) inside a module */
message VariableReference {
  int32 id = 1;
  int32 functionID = 2;
  int32 moduleID = 3;
}

/* A variable represents a storage in memory.
    It has a type, which defines what can be inside of it.
    It holds a value at runtime.
*/
message Variable {
  /* The id has to be unique inside of the function,
     that includes parameters.
  */

  /*unique*/ int32 id = 1;

  /*optional*/ string name = 2;
  TypeReference type = 3;
}

/*
  An expression that evaluates to whatever is stored at "get".
*/
message Get {
  VariableReference get = 1;
}

/* Overrides the memory location "set" is pointing to by whatever "value" evaluates to, evaluates to that "value" */
message Set {
  VariableReference set = 1;
  Expression value = 2;

  /* Wether this is the first time the variable gets Set, can't call Get before on it */
  /*parser-optional*/ bool initialization = 3;

  /* Wether Set can be called on this reference later on. The parser does it nevertheless. */
  /*parser-optional*/ bool constant = 4;
}



/* An Expression evaluates to a value at runtime. Anything inside of a function is an expression.
*/
message Expression {
 TypeReference type = 1;
 oneof expressionType {
   Get get = 2;
   Set set = 3;
   Call call = 4;
   // Access access = 4;

   FunctionReference function = 5;
   VariableReference reference = 6;

   Literal literal = 7;

   Return return = 8;
 }
}


/* If the Function that FunctionReference points to has a "parent",
    the "parent" has to be function the call is done in,
    or one of it's parents.

    Evaluates to the function's return type
*/
message Call {
  FunctionReference function = 1;
  /* The arguments */
  repeated Argument arguments = 2;
}

message Argument {
  /* matches a parameter of the called function */
  int32 id = 1;
  /* The parameter will be initialized to whatever value evaluates to */
  Expression value = 2;
}

/* evaluates to a VariableReference by accessing a ComplexType property */
// optional
// message Access {
//  Expression object = 1;
//  int32 property = 2;
// }

/*Values in the code*/
message Literal {
  oneof type {
    int32 integer = 1;
    float floating = 2;
    bool bool = 3;
    string str = 4;
    bool void = 5;
  }
}

/* Stops executing the function and returns its value */
message Return {
  Expression value = 1;
}

import "./module.proto";
import "./type.proto";

message Function {
  /* The id of this function, must be unique inside the modules functions. "main" functions got the id 0 */
  int id = 0;

  /* The name of the function. The UNI parser only uses the id and does not use
     the reference, therefore it can be removed at building time to shrink module size */
  /*parser-*/optional string name = 1;

  /* The parameters this function takes, parameters are basically just variables */
  repeated Variable parameters = 2;

  /* If a Function has a parent Function, it can only be called from within that function.
     Through that arguments of the parent function can be accessed,
     effectively enabling what's called a Closure in other languages.

     If it has no parent, it can be called from everywhere,
     the Module."main" function has to have no parent.
  */
  optional FunctionReference parent = 3;

  /* When set to true, a return inside of this function will directly
     unwind the callstack until the closest function "parent" is reached,
     then that will return with the same value this function returns.
  */
  bool innerReturn = 4;

   /* The result's type when doing a FunctionCall, equals the last Expression.type of body */
   TypeReference returns = 4;

   /* The variables can only be accessed inside this function and its children */
   repeated Variable variables = 5;

   /* The "code" executed when calling this function*/
   repeated Expression body = 6;
}

/* A way to refer to functions, "function" has to be unique inside the modules functions */
message FunctionReference {
  int moduleID = 0;
  int function = 1;
}

/* A variable reference resolves to a location in memory */
message VariableReference {
  int type = 0;
  int moduleID = 1;
}

/* A variable represents a storage in memory.
    It has a type, which defines what can be inside of it.
    It holds a value at runtime.
*/
message Variable {
  /* The id has to be unique inside of the function,
     that includes nested blocks and parameters.
  */

  /*unique*/ int id = 0;

  optional string name = 1;
  TypeReference type = 2;
}

/*
  An expression that evaluates to whatever is stored at "get".
*/
message Get {
  VariableReference get = 0;
}

/* Overrides the memory location "set" is pointing to by whatever "value" evaluates to, evaluates to that "value" */
message Set {
  VariableReference set = 0;
  Expresssion value = 1;

  /* Wether this is the first time the variable gets Set, can't call Get before on it */
  /*parser-*/optional boolean initialization = 2;

  /* Wether Set can be called on this reference later on. The parser does it nevertheless. */
  /*parser-*/optional boolean constant = 3;
}



/* An Expression evaluates to a value at runtime. Anything inside of a function is an expression.
*/
message Expression {
 required TypeReference type = 0;
 oneof type {
   Get get = 1;
   Set set = 2;
   Call call = 3;
   Access access = 4;

   FunctionReference function = 5;
   VariableReference reference = 6;

   Literal literal = 7;

   Return return = 8;
 }
}


/* If the Function that FunctionReference points to has a "parent",
    the "parent" has to be function the call is done in,
    or one of it's parents.

    Evaluates to the function's return type
*/
message Call {
  FunctionReference function = 0;
  /* The arguments */
  repeated Argument arguments = 1;
}

message Argument {
  /* matches a parameter of the called function */
  int id = 0;
  /* The parameter will be initialized to whatever value evaluates to */
  Expression value = 1;
}

/* evaluates to a VariableReference by accessing a ComplexType property */
message Access {
  Expression object = 0;
  int property = 1;
}

/*Values in the code*/
message Literal {
  oneof type {
    int integer = 0;
    float floating = 1;
    boolean bool = 2;
    string str = 3;
    boolean void = 4;
  }
}

/* Stops executing the function and returns its value */
message Return {
  required Expression value = 0;
}

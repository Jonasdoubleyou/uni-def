message Function {
  /* The id of this function, must be unique inside the modules functions. "main" functions got the id 0 */
  int id;

  /* The name of the function. The UNI parser only uses the id and does not use
     the reference, therefore it can be removed at building time to shrink module size */
  /*parser-*/optional string name;

  /* The parameters this function takes, parameters are basically just variables */
  repeated Variable parameters;

  /* If a Function has a parent Function, it can only be called from within that function.
     Through that arguments of the parent function can be accessed,
     effectively enabling what's called a Closure in other languages.

     If it has no parent, it can be called from everywhere,
     the Module."main" function has to have no parent.
  */
  optional FunctionReference parent;

  /* When set to true, a return inside of this function will directly
     unwind the callstack until the closest function "parent" is reached,
     then that will return with the same value this function returns.

     It basically solves (TS pseudocode):
     function outer(): Boolean {
       if(condition, function inner() {
          return true; <- would only exit inner, with innerReturn it returns as outer
       })
     }
  */
  boolean innerReturn;

   /* The result's type when doing a FunctionCall, equals the last Expression.type of body */
   TypeReference returns;

   /* The variables can only be accessed inside this function and its children */
   repeated Variable variables;

   /* The "code" executed when calling this function*/
   repeated Expression body;
}

/* A way to refer to functions, "function" has to be unique inside the modules functions */
message FunctionReference {
  int moduleID;
  int function;
}

/* A variable reference resolves to a location in memory */
message VariableReference {
  int type;
  int moduleID;
}

/* A variable represents a storage in memory.
    It has a type, which defines what can be inside of it.
    It holds a value at runtime.
*/
message Variable {
  /* The id has to be unique inside of the function,
     that includes nested blocks and parameters.
  */

  /*unique*/ int id;

  optional string name;
  TypeReference type;
}

/*
  An expression that evaluates to whatever is stored at "get".
*/
message Get {
  VariableReference get;
}

/* Overrides the memory location "set" is pointing to by whatever "value" evaluates to, evaluates to that "value" */
message Set {
  VariableReference set;
  Expresssion value;

  /* Wether this is the first time the variable gets Set, can't call Get before on it */
  /*parser-*/optional boolean initialization;

  /* Wether Set can be called on this reference later on. The parser does it nevertheless. */
  /*parser-*/optional boolean constant;
}



/* An Expression evaluates to a value at runtime. Anything inside of a function is an expression.
*/
message Expression {
 TypeReference type;
 oneof type {
   Get get;
   Set set;
   Call call;
   Access access;

   FunctionReference function;
   VariableReference reference;

   Literal literal;
 }
}


/* If the Function that FunctionReference points to has a "parent",
    the "parent" has to be function the call is done in,
    or one of it's parents.

    Evaluates to the function's return type
*/
message Call {
  FunctionReference function;
  /* The arguments */
  repeated Argument arguments;
}

message Argument {
  /* matches a parameter of the called function */
  int id;
  /* The parameter will be initialized to whatever value evaluates to */
  Expression value;
}

/* evaluates to a VariableReference by accessing a ComplexType property */
message Access {
  Expression object;
  int property;
}

/*Values in the code*/
message Literal {
  oneof type {
    int integer;
    float floating;
    boolean bool;
    string str;
    boolean void;
  }
}
